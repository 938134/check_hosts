#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GitHub Actions å®æµ‹é€š | ä½¿ç”¨ cloudscraper è¿‡ CF | ä¿®å¤ IPv6 æµ‹è¯• | ä½¿ç”¨ Google DNS
"""

# ======================== å¯é…ç½®åŒºåŸŸ ========================
CONFIG = {
    "default_country": "JP",
    "max_concurrent": 5,
    "ping_port": 80,
    "ping_timeout": 2,
    "dns_timeout": 10,
    "template_file": "README_template.md",
    "readme_file": "README.md",
    "hosts_file": "hosts",
    "google_dns_url": "https://dns.google/resolve",  # Google DNS API
    "max_retries": 3,
}

COUNTRY_MAP = {
    "HK": "hk", "JP": "jp", "SG": "sg", "KR": "kr",
    "TW": "tw", "US": "us", "DE": "de",
}
# ==========================================================

import argparse
import asyncio
import httpx
import random
import time
import os
import sys
import re
from datetime import datetime, timezone, timedelta
from tenacity import retry, stop_after_attempt, wait_random
import cloudscraper

HOSTS_TEMPLATE = """# IPv4 Hosts
{ipv4_content}

# IPv6 Hosts
{ipv6_content}

# Generated at: {update_time}
# Star me: https://github.com/938134/check_hosts
"""

# IPéªŒè¯æ­£åˆ™è¡¨è¾¾å¼
IPV4_PATTERN = r'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
IPV6_PATTERN = r'^(?:(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,7}:|(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}|(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}|(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}|(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:(?:(?::[0-9a-fA-F]{1,4}){1,6})|:(?:(?::[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(?::[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(?:ffff(?::0{1,4}){0,1}:){0,1}(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])|(?:[0-9a-fA-F]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$'

# ---------- å·¥å…·å‡½æ•° ----------
def validate_ip(ip):
    """éªŒè¯IPæ˜¯å¦ä¸ºåˆæ³•çš„IPv4æˆ–IPv6åœ°å€"""
    if re.match(IPV4_PATTERN, ip):
        return True, 'ipv4'
    elif re.match(IPV6_PATTERN, ip, re.IGNORECASE):
        return True, 'ipv6'
    else:
        return False, None

def load_template():
    """åŠ è½½æ¨¡æ¿æ–‡ä»¶"""
    tpl = os.path.join(os.path.dirname(__file__), CONFIG["template_file"])
    if not os.path.exists(tpl):
        print(f"æ¨¡æ¿æ–‡ä»¶ä¸å­˜åœ¨: {tpl}")
        sys.exit(1)
    with open(tpl, "r", encoding="utf-8") as f:
        return f.read()

def write_readme(ipv4_content: str, ipv6_content: str, update_time: str):
    """å†™å…¥READMEæ–‡ä»¶"""
    content = load_template().format(
        ipv4_hosts_str=ipv4_content,
        ipv6_hosts_str=ipv6_content,
        update_time=update_time,
    )
    readme_path = os.path.join(os.path.dirname(__file__), CONFIG["readme_file"])
    with open(readme_path, "w", encoding="utf-8") as f:
        f.write(content)
    print("\n~README.md å·²æ›´æ–°~")

def write_hosts(hosts_content: str):
    """å†™å…¥hostsæ–‡ä»¶"""
    hosts_path = os.path.join(os.path.dirname(__file__), CONFIG["hosts_file"])
    with open(hosts_path, "w", encoding="utf-8") as f:
        f.write(hosts_content)
    print(f"\n~æœ€æ–°Hosts {hosts_path} å·²æ›´æ–°~")

# ---------- Google DNS æŸ¥è¯¢å‡½æ•° ----------
@retry(stop=stop_after_attempt(CONFIG["max_retries"]), wait=wait_random(min=1, max=3))
def google_dns_query_sync(domain: str, record_type: str):
    """åŒæ­¥ç‰ˆæœ¬çš„ Google DNS æŸ¥è¯¢"""
    url = CONFIG["google_dns_url"]
    headers = {
        "accept": "*/*",
        "accept-encoding": "gzip, deflate, br, zstd",
        "accept-language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
        "content-type": "application/json; charset=UTF-8",
        "referer": f"https://dns.google/query?name={domain}&rr_type={record_type}&ecs=",
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 "
                      "(KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36 Edg/141.0.0.0",
    }
    
    params = {
        'name': domain,
        'type': record_type
    }
    
    print(f"[Google DNS] æŸ¥è¯¢ {record_type} è®°å½•: {domain}")
    
    try:
        response = httpx.get(url, headers=headers, params=params, timeout=CONFIG["dns_timeout"])
        print(f"[Google DNS] {domain} {record_type} - HTTP {response.status_code}")
        
        if response.status_code == 200:
            data = response.json()
            
            # è§£æAnswerå­—æ®µè·å–IP
            all_ips = []
            answer_list = data.get("Answer", [])
            
            if not answer_list:
                print(f"[Google DNS] æœªæ‰¾åˆ° {domain} çš„{record_type}è®°å½•")
                return []
            
            for answer in answer_list:
                ip = answer.get("data")
                if not ip:
                    continue
                
                # éªŒè¯IPæ ¼å¼åˆæ³•æ€§
                valid, ip_type = validate_ip(ip)
                if valid:
                    all_ips.append(ip)
                    print(f"[Google DNS] æå–åˆ°åˆæ³•{record_type} IPï¼š{ip}")
                else:
                    print(f"[Google DNS] è·³è¿‡éæ³•IPæ ¼å¼ï¼š{ip}")
            
            # å»é‡å¹¶è¿”å›
            unique_ips = list(set(all_ips))
            print(f"[Google DNS] è§£æåˆ° {len(unique_ips)} ä¸ª {record_type} IP")
            return unique_ips
        else:
            print(f"[Google DNS] æŸ¥è¯¢å¤±è´¥: {response.status_code}")
            return []
            
    except Exception as e:
        print(f"[Google DNS] æŸ¥è¯¢å¼‚å¸¸: {domain} {record_type}, é”™è¯¯: {e}")
        raise  # è§¦å‘é‡è¯•

async def google_dns_query(domain: str, record_type: str):
    """å¼‚æ­¥åŒ…è£… Google DNS æŸ¥è¯¢"""
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(None, google_dns_query_sync, domain, record_type)

# ---------- Cloudflareç»•è¿‡åŠŸèƒ½ï¼ˆå¯é€‰ï¼Œç”¨äºå…¶ä»–éœ€è¦CF bypassçš„åœºæ™¯ï¼‰ ----------
@retry(stop=stop_after_attempt(3), wait=wait_random(min=2, max=4))
def get_csrf_token_sync(udp: float, country_path: str):
    """åŒæ­¥ç‰ˆæœ¬ï¼Œä½¿ç”¨ cloudscraper ç»•è¿‡ CFï¼ˆå¦‚æœéœ€è¦è®¿é—®å…¶ä»–CFä¿æŠ¤çš„ç½‘ç«™ï¼‰"""
    url = f'https://dnschecker.org/ajax_files/gen_csrf.php?udp={udp}'
    
    headers = {
        'referer': f'https://dnschecker.org/country/{country_path}/',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 '
                      '(KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Edg/131.0.0.0',
    }
    
    print(f"[DEBUG] ä½¿ç”¨ cloudscraper è¯·æ±‚URL: {url}")
    
    # åˆ›å»º cloudscraper å®ä¾‹
    scraper = cloudscraper.create_scraper(
        browser={
            'browser': 'chrome',
            'platform': 'windows',
            'mobile': False
        }
    )
    
    try:
        resp = scraper.get(url, headers=headers, timeout=10)
        print(f"[get_csrf_token] HTTP {resp.status_code}")
        
        if resp.status_code == 403:
            print("ä»ç„¶é‡åˆ° 403ï¼Œå°è¯•å…¶ä»–æ–¹æ³•...")
            return None
            
        if resp.status_code == 200:
            data = resp.json()
            token = data.get("csrf")
            if token:
                print(f"è·å–CSRF TokenæˆåŠŸ: {token}")
                return token
                
        print(f"è·å–tokenå¤±è´¥ï¼Œå“åº”: {resp.text[:200]}")
        return None
        
    except Exception as e:
        print(f"cloudscraper è¯·æ±‚å¤±è´¥: {e}")
        return None

# å¼‚æ­¥åŒ…è£…å™¨
async def get_csrf_token(udp: float, country_path: str):
    """å¼‚æ­¥åŒ…è£…åŒæ­¥å‡½æ•°"""
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(None, get_csrf_token_sync, udp, country_path)

class HostsBuilder:
    def __init__(self, country_code: str):
        self.country_code = country_code.upper()
        if self.country_code not in COUNTRY_MAP:
            print(f"ä¸æ”¯æŒçš„å›½å®¶/åœ°åŒº: {country_code}ï¼Œæ”¯æŒåˆ—è¡¨: {list(COUNTRY_MAP.keys())}")
            sys.exit(1)
        
        self.country_path = COUNTRY_MAP[self.country_code]
        self.udp = random.random() * 1000 + (int(time.time() * 1000) % 1000)
        self.csrf_token = None

    async def get_csrf(self):
        """è·å–CSRF Tokenï¼ˆå¦‚æœéœ€è¦ï¼‰"""
        try:
            self.csrf_token = await get_csrf_token(self.udp, self.country_path)
            return self.csrf_token
        except Exception as e:
            print(f"è·å–CSRF Tokenå¤±è´¥: {e}")
            return None

    async def ping_ip(self, ip: str):
        """æ”¹è¿›çš„ ping æµ‹è¯•ï¼Œæ”¯æŒ IPv6"""
        try:
            start = time.time()
            
            # åˆ¤æ–­æ˜¯ IPv4 è¿˜æ˜¯ IPv6
            if ':' in ip:  # IPv6
                # å¯¹äº IPv6ï¼Œä½¿ç”¨æ›´ç®€å•çš„è¿é€šæ€§æµ‹è¯•
                async with httpx.AsyncClient() as client:
                    # å°è¯•ä½¿ç”¨ HTTPS è€Œä¸æ˜¯ HTTPï¼Œå› ä¸ºå¾ˆå¤š IPv6 æœåŠ¡å¯èƒ½ä¸æ”¯æŒ HTTP
                    await client.get(f"https://[{ip}]/", timeout=CONFIG["ping_timeout"])
            else:  # IPv4
                async with httpx.AsyncClient() as client:
                    await client.get(f"http://{ip}:{CONFIG['ping_port']}", timeout=CONFIG["ping_timeout"])
                    
            latency = (time.time() - start) * 1000
            return ip, latency
        except Exception as e:
            # å¦‚æœ HTTPS å¤±è´¥ï¼Œå°è¯• HTTPï¼ˆä»…å¯¹ IPv6ï¼‰
            if ':' in ip:
                try:
                    start = time.time()
                    async with httpx.AsyncClient() as client:
                        await client.get(f"http://[{ip}]:{CONFIG['ping_port']}", timeout=CONFIG["ping_timeout"])
                    latency = (time.time() - start) * 1000
                    return ip, latency
                except Exception:
                    return ip, float("inf")
            else:
                return ip, float("inf")

    async def find_fastest_ipv4(self, ips):
        """æŸ¥æ‰¾æœ€å¿«çš„ IPv4 åœ°å€"""
        if not ips:
            return None
            
        print(f"\nIPv4 å»¶è¿Ÿæµ‹è¯• ({len(ips)} ä¸ªåœ°å€):")
        tasks = [self.ping_ip(ip) for ip in ips]
        results = await asyncio.gather(*tasks)
        
        # è¿‡æ»¤æ‰è¶…æ—¶çš„ç»“æœ
        valid_results = [(ip, latency) for ip, latency in results if latency != float("inf")]
        
        if not valid_results:
            print(f"  IPv4 æ‰€æœ‰åœ°å€å‡è¶…æ—¶")
            return None
            
        fastest = min(valid_results, key=lambda x: x[1])
        
        print(f"\nIPv4 å»¶è¿Ÿæ’è¡Œ:")
        for ip, latency in sorted(valid_results, key=lambda x: x[1]):
            print(f"  {ip:<30} {latency:>7.2f}ms")
            
        return fastest[0]

    async def find_best_ipv6(self, ips):
        """æŸ¥æ‰¾æœ€ä½³çš„ IPv6 åœ°å€ï¼ˆå¦‚æœæµ‹è¯•å¤±è´¥ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªåœ°å€ï¼‰"""
        if not ips:
            return None
            
        print(f"\nIPv6 è¿é€šæ€§æµ‹è¯• ({len(ips)} ä¸ªåœ°å€):")
        tasks = [self.ping_ip(ip) for ip in ips]
        results = await asyncio.gather(*tasks)
        
        # è¿‡æ»¤æ‰è¶…æ—¶çš„ç»“æœ
        valid_results = [(ip, latency) for ip, latency in results if latency != float("inf")]
        
        if valid_results:
            # å¦‚æœæœ‰å¯ç”¨çš„ IPv6 åœ°å€ï¼Œé€‰æ‹©æœ€å¿«çš„
            fastest = min(valid_results, key=lambda x: x[1])
            print(f"\nIPv6 å»¶è¿Ÿæ’è¡Œ:")
            for ip, latency in sorted(valid_results, key=lambda x: x[1]):
                print(f"  {ip:<50} {latency:>7.2f}ms")
            return fastest[0]
        else:
            # å¦‚æœæ‰€æœ‰ IPv6 åœ°å€æµ‹è¯•éƒ½å¤±è´¥ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªåœ°å€
            # å› ä¸ºå¾ˆå¤š IPv6 åœ°å€å¯èƒ½ç”±äºé˜²ç«å¢™æ— æ³• ping é€šï¼Œä½†å®é™…è®¿é—®æ—¶å¯ç”¨
            print(f"  IPv6 å»¶è¿Ÿæµ‹è¯•å…¨éƒ¨å¤±è´¥ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªåœ°å€: {ips[0]}")
            return ips[0]

    async def fetch_domain_ips(self, domain: str):
        """è·å–åŸŸåçš„IPv4å’ŒIPv6åœ°å€ï¼ˆä½¿ç”¨Google DNSï¼‰"""
        print(f"\næŸ¥è¯¢åŸŸå: {domain}")
        
        # å¹¶å‘æŸ¥è¯¢IPv4å’ŒIPv6
        ipv4_task = google_dns_query(domain, "A")
        ipv6_task = google_dns_query(domain, "AAAA")
        
        ipv4_ips, ipv6_ips = await asyncio.gather(ipv4_task, ipv6_task)
        
        print(f"  IPv4 ç»“æœ: {len(ipv4_ips)} ä¸ªåœ°å€")
        print(f"  IPv6 ç»“æœ: {len(ipv6_ips)} ä¸ªåœ°å€")
        
        return ipv4_ips, ipv6_ips

    async def process_domain(self, domain, semaphore):
        """å¤„ç†å•ä¸ªåŸŸå"""
        async with semaphore:
            print(f"\n{'='*60}")
            print(f"æ­£åœ¨å¤„ç†: {domain}")
            print(f"{'='*60}")
            
            # è·å–IPåœ°å€ï¼ˆä½¿ç”¨Google DNSï¼‰
            ipv4_ips, ipv6_ips = await self.fetch_domain_ips(domain)
            
            # æµ‹è¯•å»¶è¿Ÿ
            fastest_ipv4 = await self.find_fastest_ipv4(ipv4_ips) if ipv4_ips else None
            fastest_ipv6 = await self.find_best_ipv6(ipv6_ips) if ipv6_ips else None
            
            print(f"\nâœ“ æœ€ä½³ IPv4: {fastest_ipv4}" if fastest_ipv4 else "âœ— æ— å¯ç”¨ IPv4")
            print(f"âœ“ æœ€ä½³ IPv6: {fastest_ipv6}" if fastest_ipv6 else "âœ— æ— å¯ç”¨ IPv6")
            
            return domain, fastest_ipv4, fastest_ipv6

    async def run(self):
        """ä¸»è¿è¡Œå‡½æ•°"""
        print(f"\nğŸš€ å¼€å§‹æ£€æµ‹æœ€å¿«IP â€”â€” ä½¿ç”¨Google DNS")
        print(f"ğŸ“Œ å›½å®¶çº¿è·¯: {self.country_code}({self.country_path})")
        print(f"âš¡ æœ€å¤§å¹¶å‘æ•°: {CONFIG['max_concurrent']}")
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦CSRF Tokenï¼ˆç›®å‰ä¸éœ€è¦ï¼Œä¿ç•™æ¥å£ï¼‰
        # await self.get_csrf()

        # è¯»å–åŸŸååˆ—è¡¨
        domains_file = os.path.join(os.path.dirname(__file__), "domains.txt")
        if not os.path.exists(domains_file):
            print(f"âŒ åŸŸåæ–‡ä»¶ä¸å­˜åœ¨: {domains_file}")
            sys.exit(1)
            
        with open(domains_file, "r", encoding="utf-8") as f:
            domains = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        
        print(f"\nğŸ“‹ å…± {len(domains)} ä¸ªåŸŸåå¾…å¤„ç†")
        
        # å¹¶å‘å¤„ç†åŸŸå
        sem = asyncio.Semaphore(CONFIG["max_concurrent"])
        tasks = [self.process_domain(d, sem) for d in domains]
        results = await asyncio.gather(*tasks)

        # æ•´ç†ç»“æœ
        ipv4_list = [(ip, dom) for dom, ip, _ in results if ip]
        ipv6_list = [(ip, dom) for dom, _, ip in results if ip]

        # ç”Ÿæˆæ›´æ–°æ—¶é—´
        update_time = datetime.now(timezone(timedelta(hours=8))).replace(microsecond=0).isoformat()
        
        # ç”Ÿæˆhostså†…å®¹
        ipv4_block = "\n".join(f"{ip:<27} {dom}" for ip, dom in ipv4_list) if ipv4_list else "# No IPv4 entries available"
        ipv6_block = "\n".join(f"{ip:<50} {dom}" for ip, dom in ipv6_list) if ipv6_list else "# No IPv6 entries available"

        # æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
        print(f"\n{'='*60}")
        print("ğŸ“Š æœ€ç»ˆç»“æœç»Ÿè®¡:")
        print(f"  âœ… IPv4 æ¡ç›®: {len(ipv4_list)}")
        print(f"  âœ… IPv6 æ¡ç›®: {len(ipv6_list)}")
        print(f"  ğŸ“… æ›´æ–°æ—¶é—´: {update_time}")
        print(f"{'='*60}")

        # ç”Ÿæˆhostsæ–‡ä»¶å†…å®¹
        hosts_content = HOSTS_TEMPLATE.format(
            ipv4_content=ipv4_block,
            ipv6_content=ipv6_block,
            update_time=update_time,
        )
        
        # å†™å…¥æ–‡ä»¶
        write_readme(ipv4_block, ipv6_block, update_time)
        write_hosts(hosts_content)
        
        print(f"\nğŸ‰ å¤„ç†å®Œæˆï¼")

# ---------- å…¥å£ ----------
async def async_main():
    """å¼‚æ­¥ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(
        description="å¤šçº¿è·¯ hosts è‡ªåŠ¨ç”Ÿæˆå™¨ï¼ˆä½¿ç”¨ Google DNS APIï¼‰",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹:
  %(prog)s                  # ä½¿ç”¨é»˜è®¤å›½å®¶(JP)
  %(prog)s -c US            # ä½¿ç”¨ç¾å›½çº¿è·¯
  %(prog)s -c SG            # ä½¿ç”¨æ–°åŠ å¡çº¿è·¯
  
æ”¯æŒçš„å›½å®¶ä»£ç : HK, JP, SG, KR, TW, US, DE
        """
    )
    
    parser.add_argument(
        "-c", "--country", 
        default=CONFIG["default_country"],
        help=f"å›½å®¶/åœ°åŒºä»£ç ï¼Œé»˜è®¤: {CONFIG['default_country']}",
        choices=list(COUNTRY_MAP.keys())
    )
    
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="å¯ç”¨è°ƒè¯•æ¨¡å¼"
    )
    
    args = parser.parse_args()
    
    # è®¾ç½®è°ƒè¯•æ¨¡å¼
    if args.debug:
        import logging
        logging.basicConfig(level=logging.DEBUG)
        print("ğŸ”§ è°ƒè¯•æ¨¡å¼å·²å¯ç”¨")
    
    # è¿è¡Œä¸»ç¨‹åº
    builder = HostsBuilder(args.country)
    await builder.run()

if __name__ == "__main__":
    try:
        asyncio.run(async_main())
    except KeyboardInterrupt:
        print("\n\nâš ï¸  ç”¨æˆ·ä¸­æ–­æ“ä½œ")
        sys.exit(0)
    except Exception as e:
        print(f"\nâŒ ç¨‹åºè¿è¡Œå‡ºé”™: {e}")
        sys.exit(1)